name: dokploy
version: v0.1.1
description: "Dokploy provider for DevPod - Create and manage development machines via Dokploy"
icon: https://raw.githubusercontent.com/Dokploy/dokploy/refs/heads/canary/apps/dokploy/logo.png

options:
  DOKPLOY_SERVER_URL:
    description: "URL of your Dokploy server (e.g., https://your-dokploy.com)"
    required: true
  DOKPLOY_API_TOKEN:
    description: "API token for Dokploy authentication (generate from Settings > Profile > API/CLI)"
    required: true
    password: true
  DOKPLOY_PROJECT_NAME:
    description: "Dokploy project name for organizing workspaces"
    default: "devpod-workspaces"
  DOKPLOY_SERVER_ID:
    description: "Dokploy server ID for multi-server deployments (optional)"
    required: false
  MACHINE_TYPE:
    description: "Machine type/size for the workspace"
    default: "small"
    enum:
      - "small"
      - "medium"
      - "large"
  AGENT_PATH:
    description: "The path where to inject the DevPod agent to"
    default: "/opt/devpod/agent"

agent:
  path: ${AGENT_PATH}
  driver: docker
  inactivityTimeout: 10m

exec:
  # Initialize the provider (test API connection)
  init: |-
    echo "Initializing Dokploy provider..."

    # Validate required options
    if [ -z "${DOKPLOY_SERVER_URL}" ] || [ -z "${DOKPLOY_API_TOKEN}" ]; then
      echo "Error: DOKPLOY_SERVER_URL and DOKPLOY_API_TOKEN are required"
      exit 1
    fi

    # Test connection to Dokploy Swagger
    echo "Testing Dokploy Swagger connection..."
    if ! curl -s -f "${DOKPLOY_SERVER_URL}/api/settings.health" \
      -H "x-api-key: ${DOKPLOY_API_TOKEN}" >/dev/null 2>&1; then
      echo "Error: Cannot connect to Dokploy server or invalid API token"
      echo "Please check:"
      echo "1. Server URL: ${DOKPLOY_SERVER_URL}"
      echo "2. API token is valid and generated from Settings > Profile > API/CLI"
      exit 1
    fi
    echo "✓ Dokploy Swagger connection successful"

    # Test SSH connection if we have a machine ID (for existing workspaces)
    if [ -n "${MACHINE_ID}" ]; then
      echo "Testing SSH connection to existing workspace..."
      
      # Get application details to test SSH connectivity
      PROJECTS_RESPONSE=$(curl -s "${DOKPLOY_SERVER_URL}/api/project.all" \
        -H "x-api-key: ${DOKPLOY_API_TOKEN}")
      
      if [ $? -eq 0 ]; then
        APPLICATION_ID=$(echo "$PROJECTS_RESPONSE" | jq -r --arg name "${MACHINE_ID}" '
          .[] | .applications[]? | select(.name == $name) | .applicationId
        ' | head -n1)
        
        if [ -n "$APPLICATION_ID" ] && [ "$APPLICATION_ID" != "null" ]; then
          API_RESPONSE=$(curl -s "${DOKPLOY_SERVER_URL}/api/application.one?applicationId=${APPLICATION_ID}" \
            -H "x-api-key: ${DOKPLOY_API_TOKEN}")
          
          SSH_PORT=$(echo "$API_RESPONSE" | jq -r '.ports[]? | select(.targetPort == 22) | .publishedPort' | head -n1)
          SSH_HOST="${DOKPLOY_SERVER_URL#*://}"  # Remove protocol
          SSH_HOST="${SSH_HOST%%/*}"             # Remove path
          SSH_HOST="${SSH_HOST%%:*}"             # Remove port
          
          if [ -n "$SSH_PORT" ] && [ "$SSH_PORT" != "null" ]; then
            echo "Testing SSH connectivity to ${SSH_HOST}:${SSH_PORT}..."
            
            # Require sshpass for SSH testing
            if ! command -v sshpass >/dev/null 2>&1; then
              echo "⚠️  sshpass not available, skipping SSH connectivity test"
            else
              # Test SSH connection with a simple echo command
              OUTPUT=$(sshpass -p "devpod" ssh -o StrictHostKeyChecking=no \
                       -o UserKnownHostsFile=/dev/null \
                       -o ConnectTimeout=10 \
                       -o PreferredAuthentications=password \
                       -o PasswordAuthentication=yes \
                       -o PubkeyAuthentication=no \
                       -p "${SSH_PORT}" \
                       "devpod@${SSH_HOST}" \
                       'echo "DevPodTest"' 2>/dev/null)
              
              if [ "$OUTPUT" = "DevPodTest" ]; then
                echo "✓ SSH connection test successful"
              else
                echo "⚠️  SSH connection test failed, but continuing (workspace may still be starting)"
              fi
            fi
          fi
        fi
      fi
    fi

    echo "Dokploy provider initialized successfully"

  # Create a new machine/container in Dokploy
  create: |-
    echo "Creating Dokploy workspace: ${MACHINE_ID}"

    # Check if project exists, create if it doesn't
    echo "Checking if project '${DOKPLOY_PROJECT_NAME}' exists..."
    PROJECT_CHECK=$(curl -s "${DOKPLOY_SERVER_URL}/api/project.all" \
      -H "x-api-key: ${DOKPLOY_API_TOKEN}" | jq -r --arg name "${DOKPLOY_PROJECT_NAME}" '.[] | select(.name == $name) | .projectId')

    if [ -z "$PROJECT_CHECK" ]; then
      echo "Project '${DOKPLOY_PROJECT_NAME}' not found. Creating project..."
      
      PROJECT_DATA=$(cat <<EOF
    {
      "name": "${DOKPLOY_PROJECT_NAME}",
      "description": "DevPod workspaces project - automatically created by Dokploy provider"
    }
    EOF
    )

      PROJECT_RESPONSE=$(curl -s -X POST "${DOKPLOY_SERVER_URL}/api/project.create" \
        -H "x-api-key: ${DOKPLOY_API_TOKEN}" \
        -H "Content-Type: application/json" \
        -d "$PROJECT_DATA")

      if [ $? -ne 0 ]; then
        echo "Error: Failed to create project in Dokploy"
        echo "Response: $PROJECT_RESPONSE"
        exit 1
      fi

      PROJECT_ID=$(echo "$PROJECT_RESPONSE" | jq -r '.projectId // .id // empty')
      if [ -z "$PROJECT_ID" ]; then
        echo "Error: Could not get project ID from response"
        echo "Response: $PROJECT_RESPONSE"
        exit 1
      fi

      echo "✓ Project created successfully with ID: $PROJECT_ID"
    else
      echo "✓ Project '${DOKPLOY_PROJECT_NAME}' already exists with ID: $PROJECT_CHECK"
      PROJECT_ID="$PROJECT_CHECK"
    fi

    # Create basic application in Dokploy
    APP_DATA=$(cat <<EOF
    {
      "name": "${MACHINE_ID}",
      "description": "DevPod workspace created on $(date)",
      "projectId": "${PROJECT_ID}"
    }
    EOF
    )

    # Create the application
    RESPONSE=$(curl -s -X POST "${DOKPLOY_SERVER_URL}/api/application.create" \
      -H "x-api-key: ${DOKPLOY_API_TOKEN}" \
      -H "Content-Type: application/json" \
      -d "$APP_DATA")

    if [ $? -ne 0 ]; then
      echo "Error: Failed to create application in Dokploy"
      echo "Response: $RESPONSE"
      exit 1
    fi

    APP_ID=$(echo "$RESPONSE" | jq -r '.applicationId // .id // empty')
    if [ -z "$APP_ID" ]; then
      echo "Error: Could not get application ID from response"
      echo "Response: $RESPONSE"
      exit 1
    fi

    echo "✓ Application created with ID: $APP_ID"

    # Configure Docker provider
    echo "Configuring Docker provider..."
    DOCKER_DATA=$(cat <<EOF
    {
      "applicationId": "${APP_ID}",
      "dockerImage": "cruizba/ubuntu-dind:latest"
    }
    EOF
    )

    DOCKER_RESPONSE=$(curl -s -X POST "${DOKPLOY_SERVER_URL}/api/application.saveDockerProvider" \
      -H "x-api-key: ${DOKPLOY_API_TOKEN}" \
      -H "Content-Type: application/json" \
      -d "$DOCKER_DATA")

    if [ $? -ne 0 ]; then
      echo "Error: Failed to configure Docker provider"
      echo "Response: $DOCKER_RESPONSE"
      exit 1
    fi

    echo "✓ Docker provider configured"

    # Configure environment variables
    echo "Configuring environment variables..."
    ENV_DATA=$(cat <<EOF
    {
      "applicationId": "${APP_ID}",
      "env": "DEVPOD_WORKSPACE=true"
    }
    EOF
    )

    ENV_RESPONSE=$(curl -s -X POST "${DOKPLOY_SERVER_URL}/api/application.saveEnvironment" \
      -H "x-api-key: ${DOKPLOY_API_TOKEN}" \
      -H "Content-Type: application/json" \
      -d "$ENV_DATA")

    if [ $? -ne 0 ]; then
      echo "Error: Failed to configure environment variables"
      echo "Response: $ENV_RESPONSE"
      exit 1
    fi

    echo "✓ Environment variables configured"

    # Update application with SSH setup command
    echo "Configuring application for SSH access..."

    # Use cruizba/ubuntu-dind which has Docker pre-installed and running
    # Break the setup into stages with progress feedback to handle apt-get update delays
    UPDATE_DATA="{\"applicationId\": \"${APP_ID}\", \"command\": \"sh -c 'echo \\\"=== DevPod SSH Setup Starting ===\\\" && echo \\\"Stage 1/4: Updating package lists (this may take 1-2 minutes)...\\\" && apt-get update -qq && echo \\\"✓ Package lists updated\\\" && echo \\\"Stage 2/4: Installing SSH server and sudo...\\\" && apt-get install -y -qq openssh-server sudo && echo \\\"✓ SSH server installed\\\" && echo \\\"Stage 3/4: Creating devpod user and configuring permissions...\\\" && useradd -m -s /bin/bash devpod && echo \\\"devpod:devpod\\\" | chpasswd && echo \\\"devpod ALL=(ALL) NOPASSWD:ALL\\\" >> /etc/sudoers && (getent group docker >/dev/null || groupadd docker) && usermod -aG docker devpod && mkdir -p /home/devpod/.ssh && chmod 700 /home/devpod/.ssh && chown devpod:devpod /home/devpod/.ssh && echo \\\"✓ User devpod configured\\\" && echo \\\"Stage 4/4: Configuring SSH daemon...\\\" && mkdir -p /run/sshd && ssh-keygen -A && echo \\\"PubkeyAuthentication yes\\\" >> /etc/ssh/sshd_config && echo \\\"AuthorizedKeysFile .ssh/authorized_keys\\\" >> /etc/ssh/sshd_config && echo \\\"PasswordAuthentication yes\\\" >> /etc/ssh/sshd_config && echo \\\"PermitRootLogin no\\\" >> /etc/ssh/sshd_config && echo \\\"Port 22\\\" >> /etc/ssh/sshd_config && echo \\\"✓ SSH daemon configured\\\" && echo \\\"=== DevPod SSH Setup Complete - Starting SSH daemon ===\\\" && exec /usr/sbin/sshd -D -e'\"}"

    UPDATE_RESPONSE=$(curl -s -X POST "${DOKPLOY_SERVER_URL}/api/application.update" \
      -H "x-api-key: ${DOKPLOY_API_TOKEN}" \
      -H "Content-Type: application/json" \
      -d "$UPDATE_DATA")

    if [ $? -ne 0 ]; then
      echo "Error: Failed to update application with SSH setup"
      echo "Response: $UPDATE_RESPONSE"
      exit 1
    fi

    echo "✓ Application configured with SSH setup command"

    # Deploy the application with SSH configuration
    echo "Deploying application with SSH configuration..."
    echo "NOTE: Using Ubuntu Docker-in-Docker container with pre-installed Docker"
    echo "      DevPod will connect via SSH and inject its agent automatically"
    echo ""
    echo "⏳ Container Setup Timeline:"
    echo "   • Stage 1: Package update (1-2 minutes) - apt-get update"
    echo "   • Stage 2: SSH installation (30-60 seconds) - install openssh-server"
    echo "   • Stage 3: User setup (10-20 seconds) - create devpod user"
    echo "   • Stage 4: SSH configuration (10-20 seconds) - configure SSH daemon"
    echo "   • Total estimated time: 2-4 minutes"
    echo ""

    DEPLOY_RESPONSE=$(curl -s -X POST "${DOKPLOY_SERVER_URL}/api/application.deploy" \
      -H "x-api-key: ${DOKPLOY_API_TOKEN}" \
      -H "Content-Type: application/json" \
      -d "{\"applicationId\": \"$APP_ID\"}")

    if [ $? -ne 0 ]; then
      echo "Error: Failed to deploy application"
      echo "Response: $DEPLOY_RESPONSE"
      exit 1
    fi

    echo "✓ Deployment started with SSH configuration"

    # Wait for deployment to complete with better progress feedback
    echo "Waiting for container setup to complete..."
    echo "ℹ️  The container is now running the 4-stage SSH setup process."
    echo "   If this takes longer than expected, the apt-get update stage may be slow."
    echo ""

    SETUP_START_TIME=$(date +%s)
    for i in $(seq 1 60); do
      STATUS=$(curl -s "${DOKPLOY_SERVER_URL}/api/application.one?applicationId=$APP_ID" \
        -H "x-api-key: ${DOKPLOY_API_TOKEN}" | jq -r '.applicationStatus // "unknown"')
      
      CURRENT_TIME=$(date +%s)
      ELAPSED_TIME=$((CURRENT_TIME - SETUP_START_TIME))
      
      if [ "$STATUS" = "done" ]; then
        echo "✓ Container setup completed successfully (${ELAPSED_TIME}s elapsed)"
        break
      elif [ "$STATUS" = "error" ]; then
        echo "⚠️  Container setup failed, but continuing..."
        break
      fi
      
      # Provide stage-specific feedback based on elapsed time
      if [ $ELAPSED_TIME -lt 60 ]; then
        STAGE_INFO="(likely Stage 1: apt-get update)"
      elif [ $ELAPSED_TIME -lt 120 ]; then
        STAGE_INFO="(likely Stage 1-2: package update/SSH install)"
      elif [ $ELAPSED_TIME -lt 180 ]; then
        STAGE_INFO="(likely Stage 2-3: SSH install/user setup)"
      else
        STAGE_INFO="(likely Stage 3-4: user/SSH configuration)"
      fi
      
      echo "   Setup status: $STATUS - ${ELAPSED_TIME}s elapsed $STAGE_INFO (attempt $i/60)"
      sleep 5
    done

    # Automatically configure SSH port mapping via API
    echo "Configuring SSH port mapping via Dokploy Swagger..."

    # Extract Dokploy host from server URL using shell parameter expansion
    SSH_HOST="${DOKPLOY_SERVER_URL#*://}"  # Remove protocol
    SSH_HOST="${SSH_HOST%%/*}"             # Remove path
    SSH_HOST="${SSH_HOST%%:*}"             # Remove port

    # Simple approach: try ports one by one until we find one that works
    # Note: Dokploy Swagger doesn't have a port.all endpoint to check existing ports,
    # and Docker Swarm can have silent port conflicts, so we need to verify actual accessibility
    SSH_HOST_PORT=""
    PORT_CREATED=false
    echo "Searching for available SSH port (trying ports 2222-2230)..."
    echo "DEBUG: Starting port allocation loop..."
    echo "DEBUG: Will test port accessibility on host: $SSH_HOST"

    for port in 2222 2223 2224 2225 2226 2227 2228 2229 2230; do
      echo "DEBUG: === Trying port $port ==="
      echo "DEBUG: PORT_CREATED status before attempt: $PORT_CREATED"
      
      # Check if we already created a port (safety check)
      if [ "$PORT_CREATED" = "true" ]; then
        echo "DEBUG: Port already created, breaking out of loop"
        break
      fi
      
      echo "Trying port $port..."
      
      # Pre-check: Test if port is already in use before API call
      echo "DEBUG: Pre-checking port availability on $SSH_HOST:$port..."
      PORT_PRECHECK_AVAILABLE=false
      
      # Test if SSH daemon is responding on this port (more accurate than nc/telnet)
      SSH_PRECHECK_OUTPUT=$(ssh -o StrictHostKeyChecking=no \
                               -o UserKnownHostsFile=/dev/null \
                               -o ConnectTimeout=3 \
                               -o PreferredAuthentications=none \
                               -p "$port" "test@$SSH_HOST" 2>&1 || true)
      
      # If we get any SSH-related response, the port is in use by SSH
      if echo "$SSH_PRECHECK_OUTPUT" | grep -q "Permission denied\|publickey\|password\|Connection closed\|SSH\|OpenSSH"; then
        echo "DEBUG: ❌ Port $port is already in use by SSH service (pre-check failed)"
        echo "   Port $port is already bound by another SSH service"
        echo "   Skipping API call and trying next port..."
        continue
      elif echo "$SSH_PRECHECK_OUTPUT" | grep -q "Connection refused\|No route to host\|Connection timed out"; then
        echo "DEBUG: ✅ Port $port appears available (pre-check passed)"
        PORT_PRECHECK_AVAILABLE=true
      else
        echo "DEBUG: ✅ Port $port appears available (pre-check passed - no SSH response)"
        PORT_PRECHECK_AVAILABLE=true
      fi
      
      # Only proceed with API call if pre-check passed
      if [ "$PORT_PRECHECK_AVAILABLE" = "true" ]; then
        echo "DEBUG: Port $port pre-check passed, proceeding with API call..."
      else
        echo "DEBUG: Port $port pre-check failed, skipping..."
        continue
      fi
      
      # Try to create the port mapping
      PORT_DATA="{\"publishedPort\": $port, \"targetPort\": 22, \"protocol\": \"tcp\", \"applicationId\": \"$APP_ID\"}"
      echo "DEBUG: Sending API request for port $port..."
      echo "DEBUG: Request data: $PORT_DATA"
      
      PORT_RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code}" -X POST "${DOKPLOY_SERVER_URL}/api/port.create" \
        -H "x-api-key: ${DOKPLOY_API_TOKEN}" \
        -H "Content-Type: application/json" \
        -d "$PORT_DATA")
      
      # Extract HTTP status and response body
      HTTP_STATUS=$(echo "$PORT_RESPONSE" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
      RESPONSE_BODY=$(echo "$PORT_RESPONSE" | sed 's/HTTPSTATUS:[0-9]*$//')
      
      echo "DEBUG: HTTP Status: $HTTP_STATUS"
      echo "DEBUG: Response Body: $RESPONSE_BODY"
      
      # Check if the API call was successful (HTTP 200/201)
      if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "201" ]; then
        echo "DEBUG: API call succeeded, checking response..."
        echo "DEBUG: Full response body: '$RESPONSE_BODY'"
        
        # Check if response is an error object (even with 200 status)
        ERROR_MESSAGE=$(echo "$RESPONSE_BODY" | jq -r '.message // empty' 2>/dev/null)
        ERROR_CODE=$(echo "$RESPONSE_BODY" | jq -r '.code // empty' 2>/dev/null)
        HAS_ISSUES=$(echo "$RESPONSE_BODY" | jq -r '.issues // empty' 2>/dev/null)
        
        echo "DEBUG: Parsed error_message: '$ERROR_MESSAGE'"
        echo "DEBUG: Parsed error_code: '$ERROR_CODE'"
        echo "DEBUG: Parsed issues: '$HAS_ISSUES'"
        
        # If we have error message/code/issues, this is an error response
        if [ -n "$ERROR_MESSAGE" ] && [ "$ERROR_MESSAGE" != "empty" ] && [ "$ERROR_MESSAGE" != "null" ]; then
          echo "   Port $port failed: $ERROR_MESSAGE"
          if [ -n "$ERROR_CODE" ] && [ "$ERROR_CODE" != "empty" ]; then
            echo "   Error code: $ERROR_CODE"
          fi
          if [ -n "$HAS_ISSUES" ] && [ "$HAS_ISSUES" != "empty" ] && [ "$HAS_ISSUES" != "null" ]; then
            echo "   Issues: $HAS_ISSUES"
          fi
          echo "DEBUG: Port creation failed due to API error, continuing to next port..."
        # Check if we got a simple success response (boolean true)
        elif [ "$RESPONSE_BODY" = "true" ]; then
          # API success! Port mapping created
          echo "✅ Port $port API mapping created successfully!"
          echo "   Response: $RESPONSE_BODY"
          echo "   Mapping: $port (host) → 22 (container)"
          echo "DEBUG: API succeeded, marking port as created..."
          
          # Success! Port mapping created via API
          SSH_HOST_PORT=$port
          PORT_CREATED=true
          echo "🎉 Port $port API mapping completed!"
          echo "   ✅ API mapping created successfully"
          echo "   ⏳ Port accessibility will be verified in final SSH testing phase"
          echo "DEBUG: Setting PORT_CREATED=true and breaking..."
          break
        else
          # Check if we got a port object with ID (alternative success format)
          PORT_ID=$(echo "$RESPONSE_BODY" | jq -r '.portId // .id // empty' 2>/dev/null)
          echo "DEBUG: Extracted port ID: '$PORT_ID'"
          
          if [ -n "$PORT_ID" ] && [ "$PORT_ID" != "null" ] && [ "$PORT_ID" != "empty" ]; then
            # API success with port ID! Port mapping created
            echo "✅ Port $port API mapping created successfully!"
            echo "   Port ID: $PORT_ID"
            echo "   Mapping: $port (host) → 22 (container)"
            echo "DEBUG: API succeeded with port ID, marking port as created..."
            
            # Success! Port mapping created via API
            SSH_HOST_PORT=$port
            PORT_CREATED=true
            echo "🎉 Port $port API mapping completed!"
            echo "   ✅ API mapping created successfully"
            echo "   ⏳ Port accessibility will be verified in final SSH testing phase"
            echo "DEBUG: Setting PORT_CREATED=true and breaking..."
            break
          else
            # Unknown response format
            echo "   Port $port failed: Unknown response format"
            echo "   Response: $RESPONSE_BODY"
            echo "DEBUG: Unknown response format, continuing to next port..."
          fi
        fi
      else
        # HTTP error - extract error message from Dokploy Swagger response format
        ERROR_MSG=$(echo "$RESPONSE_BODY" | jq -r '.message // "HTTP error"' 2>/dev/null)
        ERROR_CODE=$(echo "$RESPONSE_BODY" | jq -r '.code // ""' 2>/dev/null)
        
        if [ -n "$ERROR_CODE" ]; then
          echo "   Port $port failed (HTTP $HTTP_STATUS): $ERROR_MSG (Code: $ERROR_CODE)"
        else
          echo "   Port $port failed (HTTP $HTTP_STATUS): $ERROR_MSG"
        fi
        echo "DEBUG: HTTP error, continuing to next port..."
      fi
      
      echo "DEBUG: End of iteration for port $port"
      echo "DEBUG: PORT_CREATED status after attempt: $PORT_CREATED"
    done

    echo "DEBUG: Exited port allocation loop"
    echo "DEBUG: Final PORT_CREATED status: $PORT_CREATED"
    echo "DEBUG: Final SSH_HOST_PORT: $SSH_HOST_PORT"

    # Check if we successfully created a port mapping
    if [ "$PORT_CREATED" = "true" ] && [ -n "$SSH_HOST_PORT" ]; then
      echo ""
      echo "🎉 SSH port mapping configured successfully!"
      echo "   Using port: $SSH_HOST_PORT"
      echo "DEBUG: Proceeding with redeployment..."
      
      # Redeploy to apply the port mapping
      echo "Redeploying application to apply port mapping..."
      curl -s -X POST "${DOKPLOY_SERVER_URL}/api/application.deploy" \
        -H "x-api-key: ${DOKPLOY_API_TOKEN}" \
        -H "Content-Type: application/json" \
        -d "{\"applicationId\": \"$APP_ID\"}" >/dev/null

      # Wait for redeployment
      echo "Waiting for redeployment to complete..."
      for i in $(seq 1 30); do
        STATUS=$(curl -s "${DOKPLOY_SERVER_URL}/api/application.one?applicationId=$APP_ID" \
          -H "x-api-key: ${DOKPLOY_API_TOKEN}" | jq -r '.applicationStatus // "unknown"')
        
        if [ "$STATUS" = "done" ]; then
          echo "✓ Redeployment completed successfully"
          break
        elif [ "$STATUS" = "error" ]; then
          echo "⚠️  Redeployment failed, but continuing..."
          break
        fi
        
        echo "   Redeployment status: $STATUS (attempt $i/30)"
        sleep 5
      done
    else
      echo ""
      echo "❌ CRITICAL ERROR: Could not configure SSH port mapping"
      echo "   All ports in range 2222-2230 are in use or unavailable."
      echo ""
      echo "This is a critical failure because SSH access is required for DevPod to function."
      echo "Please manually free up a port in the range 2222-2230 and try again."
      echo ""
      echo "To debug this issue:"
      echo "1. Check your Dokploy dashboard: $DOKPLOY_SERVER_URL"
      echo "2. Look for existing port mappings in other applications"
      echo "3. Delete unused applications or port mappings"
      echo "4. Try creating the workspace again"
      echo ""
      echo "Failing workspace creation due to inability to configure SSH access."
      exit 1
    fi

    # Set SSH connection variables (SSH_HOST already extracted earlier)
    SSH_HOST="$SSH_HOST"
    SSH_PORT="$SSH_HOST_PORT"

    echo ""
    echo "SSH connection details:"
    echo "Host: $SSH_HOST"
    echo "Port: $SSH_PORT"
    echo "User: devpod"
    echo ""

    if [ "$SSH_HOST_PORT" != "22" ]; then
      echo "✅ SSH port mapping configured automatically!"
      echo "SSH access should be available on port $SSH_HOST_PORT"
    else
      echo "⚠️  Manual SSH port configuration required:"
      echo "1. Open Dokploy dashboard: $DOKPLOY_SERVER_URL"
      echo "2. Navigate to your application: $APP_ID"
      echo "3. Go to Advanced > Ports"
      echo "4. Add port mapping: Container Port 22 -> Host Port 2222"
      echo "5. Redeploy the application"
    fi
    echo ""

    # Test SSH connection with retries
    echo "Testing SSH port availability on $SSH_HOST:$SSH_PORT..."
    echo "DEBUG: Starting SSH port availability check..."
    echo "DEBUG: SSH_HOST='$SSH_HOST'"
    echo "DEBUG: SSH_PORT='$SSH_PORT'"

    PORT_READY=false

    # Wait longer for port mapping and SSH daemon to be fully ready
    echo "Waiting for SSH daemon and port mapping to be fully active..."
    echo ""
    echo "ℹ️  NOTICE: Docker Swarm Port Mapping Delay"
    echo "   Dokploy uses Docker Swarm for container orchestration, which requires"
    echo "   time for port mappings to propagate across the cluster. This 60+ second"
    echo "   delay is normal and expected behavior, not a provider issue."
    echo ""
    echo "   • Port mapping API: ✅ Completed successfully"
    echo "   • Port propagation: ⏳ In progress (60-120 seconds typical)"
    echo "   • SSH accessibility: ⏳ Will be available after propagation"
    echo ""
    echo "DEBUG: Sleeping for 30 seconds to allow Dokploy port mapping to propagate..."
    sleep 30

    # Pre-connection diagnostics
    echo "DEBUG: Running port availability diagnostics..."

    # Test basic network connectivity to the host
    echo "DEBUG: Testing basic network connectivity to $SSH_HOST..."
    if ping -c 1 -W 3 "$SSH_HOST" >/dev/null 2>&1; then
      echo "DEBUG: ✓ Host $SSH_HOST is reachable via ping"
    else
      echo "DEBUG: ⚠️  Host $SSH_HOST is not responding to ping (may be normal if ICMP is blocked)"
    fi

    # Test if the port is open and SSH daemon is responding
    echo "DEBUG: Testing if SSH daemon is accessible on port $SSH_PORT..."

    # Try multiple times with time-based retry for port to become accessible (120 seconds)
    RETRY_START_TIME=$(date +%s)
    RETRY_TIMEOUT=120
    RETRY_INTERVAL=10
    RETRY_COUNT=0

    while true; do
      CURRENT_TIME=$(date +%s)
      ELAPSED_TIME=$((CURRENT_TIME - RETRY_START_TIME))
      RETRY_COUNT=$((RETRY_COUNT + 1))
      
      echo "DEBUG: Port availability test attempt $RETRY_COUNT (${ELAPSED_TIME}s elapsed, ${RETRY_TIMEOUT}s timeout)..."
      
      # Test port connectivity
      PORT_ACCESSIBLE=false
      if command -v nc >/dev/null 2>&1; then
        if nc -z -w 10 "$SSH_HOST" "$SSH_PORT" 2>/dev/null; then
          echo "DEBUG: ✓ Port $SSH_PORT is open and accepting connections"
          PORT_ACCESSIBLE=true
        else
          echo "DEBUG: ❌ Port $SSH_PORT not accessible on attempt $RETRY_COUNT"
        fi
      elif command -v telnet >/dev/null 2>&1; then
        if echo "" | telnet "$SSH_HOST" "$SSH_PORT" 2>/dev/null | grep -q "Connected"; then
          echo "DEBUG: ✓ Port $SSH_PORT is open and accepting connections"
          PORT_ACCESSIBLE=true
        else
          echo "DEBUG: ❌ Port $SSH_PORT not accessible on attempt $RETRY_COUNT"
        fi
      else
        echo "DEBUG: ⚠️  No netcat or telnet available for port testing, assuming port is ready"
        PORT_ACCESSIBLE=true
      fi
      
      # Test if SSH daemon is responding (just check for SSH banner, no auth)
      SSH_DAEMON_RESPONDING=false
      if [ "$PORT_ACCESSIBLE" = "true" ]; then
        echo "DEBUG: Testing SSH daemon response..."
        # Simple test - if we can connect and get any response, SSH daemon is working
        SSH_TEST_OUTPUT=$(ssh -o StrictHostKeyChecking=no \
                             -o UserKnownHostsFile=/dev/null \
                             -o ConnectTimeout=5 \
                             -o PreferredAuthentications=none \
                             -p "$SSH_PORT" "test@$SSH_HOST" 2>&1 || true)
        
        # If we get any SSH-related response (including connection closed), daemon is responding
        if echo "$SSH_TEST_OUTPUT" | grep -q "Permission denied\|publickey\|password\|Connection closed\|SSH\|OpenSSH"; then
          echo "DEBUG: ✓ SSH daemon is responding"
          SSH_DAEMON_RESPONDING=true
        else
          echo "DEBUG: ❌ SSH daemon not responding properly on attempt $RETRY_COUNT"
          echo "DEBUG: SSH response: $SSH_TEST_OUTPUT"
        fi
      fi
      
      # Check if both port and SSH daemon are ready
      if [ "$PORT_ACCESSIBLE" = "true" ] && [ "$SSH_DAEMON_RESPONDING" = "true" ]; then
        echo "✅ SSH port and daemon are ready!"
        echo "   Port $SSH_PORT is accessible and SSH daemon is responding"
        echo "   Total time: ${ELAPSED_TIME} seconds"
        PORT_READY=true
        break
      fi
      
      # Check if we've exceeded the timeout
      if [ $ELAPSED_TIME -ge $RETRY_TIMEOUT ]; then
        echo "⏰ SSH connection timeout reached (${RETRY_TIMEOUT}s)"
        echo "   Port $SSH_PORT may still be propagating"
        echo "   DevPod will continue retrying when it attempts to connect"
        break
      fi
      
      # Wait before next retry
      echo "DEBUG: Waiting ${RETRY_INTERVAL} seconds before next attempt..."
      sleep $RETRY_INTERVAL
    done

    # Report final status
    if [ "$PORT_READY" = "true" ]; then
      echo "✅ SSH service is ready for DevPod connection!"
      echo "   DevPod can now connect and inject its agent"
    else
      echo "⚠️  SSH port availability check incomplete"
      echo "   Port may still be propagating, DevPod will retry connections as needed"
      echo "   SSH should be available shortly on $SSH_HOST:$SSH_PORT"
    fi

    echo ""
    echo "✅ Dokploy workspace created successfully!"

    if [ "$PORT_READY" = "true" ]; then
      echo "🎉 SSH port is ready and accessible!"
      echo "DevPod can now connect and set up authentication automatically"
    elif [ "$SSH_HOST_PORT" != "22" ]; then
      echo "⚠️  SSH port mapping configured, waiting for full availability"
      echo "DevPod will retry connections until the port is fully accessible"
    else
      echo "⚠️  Manual SSH configuration required for full functionality"
    fi

    echo ""
    echo "Workspace Details:"
    echo "- Application ID: $APP_ID"
    echo "- SSH Host: $SSH_HOST"
    echo "- SSH Port: $SSH_PORT"
    echo "- SSH User: devpod"
    echo "- SSH Auth: Hybrid (password + key) - DevPod will inject keys automatically"
    echo "- Base Image: cruizba/ubuntu-dind (Ubuntu with Docker-in-Docker)"
    echo "- Dokploy Dashboard: $DOKPLOY_SERVER_URL"
    echo ""
    echo "Next Steps:"
    echo "- DevPod will connect via SSH and inject its agent"
    echo "- The agent will handle authentication, credentials, and workspace setup"
    echo "- Docker is pre-installed and ready for development containers"
    echo "- Container will auto-shutdown after inactivity (10m configured)"

    # Return connection info to DevPod (MUST BE LAST OUTPUT)
    echo "DEVPOD_MACHINE_ID=$APP_ID"
    echo "DEVPOD_MACHINE_HOST=$SSH_HOST"
    echo "DEVPOD_MACHINE_PORT=$SSH_PORT"
    echo "DEVPOD_MACHINE_USER=devpod"

  # Delete the machine
  delete: |-
    echo "Deleting Dokploy workspace: ${DEVPOD_MACHINE_ID}"

    if [ -z "${DEVPOD_MACHINE_ID}" ]; then
      echo "Error: No machine ID provided"
      exit 1
    fi

    # Delete the application
    curl -s -X DELETE "${DOKPLOY_SERVER_URL}/api/application.remove" \
      -H "x-api-key: ${DOKPLOY_API_TOKEN}" \
      -H "Content-Type: application/json" \
      -d "{\"applicationId\": \"${DEVPOD_MACHINE_ID}\"}"

    echo "✓ Dokploy workspace deleted"

  # Start a stopped machine
  start: |-
    echo "Starting Dokploy workspace: ${DEVPOD_MACHINE_ID}"

    if [ -z "${DEVPOD_MACHINE_ID}" ]; then
      echo "Error: No machine ID provided"
      exit 1
    fi

    # Start the application
    curl -s -X POST "${DOKPLOY_SERVER_URL}/api/application.start" \
      -H "x-api-key: ${DOKPLOY_API_TOKEN}" \
      -H "Content-Type: application/json" \
      -d "{\"applicationId\": \"${DEVPOD_MACHINE_ID}\"}"

    echo "✓ Dokploy workspace started"

  # Stop the machine
  stop: |-
    echo "Stopping Dokploy workspace: ${DEVPOD_MACHINE_ID}"

    if [ -z "${DEVPOD_MACHINE_ID}" ]; then
      echo "Error: No machine ID provided"
      exit 1
    fi

    # Stop the application
    curl -s -X POST "${DOKPLOY_SERVER_URL}/api/application.stop" \
      -H "x-api-key: ${DOKPLOY_API_TOKEN}" \
      -H "Content-Type: application/json" \
      -d "{\"applicationId\": \"${DEVPOD_MACHINE_ID}\"}"

    echo "✓ Dokploy workspace stopped"

  # Get machine status
  status: |-
    echo "DEBUG: Starting status check for machine: ${DEVPOD_MACHINE_ID}" >&2

    if [ -z "${DEVPOD_MACHINE_ID}" ]; then
      echo "DEBUG: No machine ID provided, returning NotFound" >&2
      echo "NotFound"
      exit 0
    fi

    echo "DEBUG: Calling Dokploy Swagger..." >&2
    echo "DEBUG: URL: ${DOKPLOY_SERVER_URL}/api/application.one?applicationId=${DEVPOD_MACHINE_ID}" >&2

    # Get application status with debug output
    API_RESPONSE=$(curl -s "${DOKPLOY_SERVER_URL}/api/application.one?applicationId=${DEVPOD_MACHINE_ID}" \
      -H "x-api-key: ${DOKPLOY_API_TOKEN}")

    echo "DEBUG: Raw API response: $API_RESPONSE" >&2

    STATUS=$(echo "$API_RESPONSE" | jq -r '.applicationStatus // "unknown"')

    echo "DEBUG: Extracted status: '$STATUS'" >&2

    case "$STATUS" in
      "done"|"running")
        echo "DEBUG: Status '$STATUS' mapped to 'Running'" >&2
        echo "Running"
        ;;
      "idle")
        echo "DEBUG: Status '$STATUS' mapped to 'Stopped'" >&2
        echo "Stopped"
        ;;
      "error")
        echo "DEBUG: Status '$STATUS' mapped to 'NotFound'" >&2
        echo "NotFound"
        ;;
      *)
        echo "DEBUG: Status '$STATUS' mapped to 'Busy' (default case)" >&2
        echo "Busy"
        ;;
    esac

    echo "DEBUG: Status check completed" >&2

  # Execute commands via SSH
  command: |-
    # Get all projects and applications to find the application by name
    PROJECTS_RESPONSE=$(curl -s "${DOKPLOY_SERVER_URL}/api/project.all" \
      -H "x-api-key: ${DOKPLOY_API_TOKEN}")

    if [ $? -ne 0 ]; then
      echo "Error: Failed to retrieve projects from Dokploy Swagger" >&2
      exit 1
    fi

    # Find the application with matching name (MACHINE_ID is the application name)
    APPLICATION_ID=$(echo "$PROJECTS_RESPONSE" | jq -r --arg name "${MACHINE_ID}" '
      .[] | .applications[]? | select(.name == $name) | .applicationId
    ' | head -n1)

    if [ -z "$APPLICATION_ID" ] || [ "$APPLICATION_ID" = "null" ]; then
      echo "Error: No application found with name '${MACHINE_ID}'" >&2
      exit 1
    fi

    # Get application details including port mappings
    API_RESPONSE=$(curl -s "${DOKPLOY_SERVER_URL}/api/application.one?applicationId=${APPLICATION_ID}" \
      -H "x-api-key: ${DOKPLOY_API_TOKEN}")

    if [ $? -ne 0 ]; then
      echo "Error: Failed to retrieve application details" >&2
      exit 1
    fi

    # Extract SSH port mapping from the ports array
    SSH_PORT=$(echo "$API_RESPONSE" | jq -r '.ports[]? | select(.targetPort == 22) | .publishedPort' | head -n1)

    if [ -z "$SSH_PORT" ] || [ "$SSH_PORT" = "null" ]; then
      echo "Error: No SSH port mapping found for application" >&2
      exit 1
    fi

    # Extract Dokploy host from server URL using shell parameter expansion
    SSH_HOST="${DOKPLOY_SERVER_URL#*://}"  # Remove protocol
    SSH_HOST="${SSH_HOST%%/*}"             # Remove path
    SSH_HOST="${SSH_HOST%%:*}"             # Remove port

    # Execute command via SSH using sshpass for password authentication
    if ! command -v sshpass >/dev/null 2>&1; then
      echo "Error: sshpass is required for password authentication" >&2
      echo "Please install sshpass:" >&2
      echo "  macOS: brew install hudochenkov/sshpass/sshpass" >&2
      echo "  Ubuntu/Debian: sudo apt-get install sshpass" >&2
      echo "  CentOS/RHEL: sudo yum install sshpass" >&2
      exit 1
    fi

    sshpass -p "devpod" ssh -o StrictHostKeyChecking=no \
        -o UserKnownHostsFile=/dev/null \
        -o ConnectTimeout=30 \
        -o ServerAliveInterval=5 \
        -o ServerAliveCountMax=3 \
        -o PreferredAuthentications=password \
        -o PasswordAuthentication=yes \
        -o PubkeyAuthentication=no \
        -p "${SSH_PORT}" \
        "devpod@${SSH_HOST}" \
        "${COMMAND}"
